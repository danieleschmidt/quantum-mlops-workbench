# Automated Release Management for Quantum ML Projects
#
# This workflow provides automated release management including:
# - Semantic versioning based on conventional commits
# - Quantum model artifact packaging
# - Multi-platform container builds
# - Documentation deployment
# - Release notes generation

name: Automated Release & Deployment

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'pyproject.toml'
      - 'requirements*.txt'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release to create'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - prerelease
      skip_tests:
        description: 'Skip comprehensive testing before release'
        required: false
        default: false
        type: boolean
      deploy_environment:
        description: 'Environment to deploy to'
        required: false
        default: 'production'
        type: choice
        options:
          - staging
          - production
          - all

env:
  # Release configuration
  PACKAGE_NAME: quantum-mlops-workbench
  CONTAINER_REGISTRY: ghcr.io
  PYTHON_VERSION: '3.11'
  
  # Quantum-specific release settings
  QUANTUM_MODEL_REGISTRY: mlflow
  QUANTUM_ARTIFACT_RETENTION: 365  # days
  
  # Multi-platform build targets
  BUILD_PLATFORMS: linux/amd64,linux/arm64

permissions:
  contents: write
  packages: write
  id-token: write
  attestations: write
  pull-requests: write

jobs:
  # Determine release version and type
  determine-release:
    name: Determine Release Version
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.release_check.outputs.should_release }}
      release_version: ${{ steps.release_check.outputs.release_version }}
      release_type: ${{ steps.release_check.outputs.release_type }}
      previous_version: ${{ steps.release_check.outputs.previous_version }}
      changelog: ${{ steps.release_check.outputs.changelog }}
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for changelog
    
    - name: Setup Python Environment
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Install Release Tools
      run: |
        python -m pip install --upgrade pip
        pip install semantic-version gitpython
    
    - name: Analyze Commits for Release
      id: release_check
      run: |
        python scripts/release/analyze_commits.py \
          --manual-release-type="${{ github.event.inputs.release_type }}" \
          --output-env >> $GITHUB_OUTPUT
    
    - name: Generate Changelog
      if: steps.release_check.outputs.should_release == 'true'
      run: |
        python scripts/release/generate_changelog.py \
          --from-version "${{ steps.release_check.outputs.previous_version }}" \
          --to-version "${{ steps.release_check.outputs.release_version }}" \
          --output CHANGELOG_CURRENT.md \
          --format markdown \
          --include-quantum-features

  # Pre-release testing and validation
  pre-release-testing:
    name: Pre-Release Testing
    runs-on: ubuntu-latest
    needs: [determine-release]
    if: |
      needs.determine-release.outputs.should_release == 'true' &&
      github.event.inputs.skip_tests != 'true'
    
    strategy:
      fail-fast: true
      matrix:
        python-version: ['3.9', '3.10', '3.11', '3.12']
        quantum-framework: ['pennylane', 'qiskit']
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Setup Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'
    
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev,${{ matrix.quantum-framework }}]"
    
    - name: Run Comprehensive Tests
      run: |
        pytest tests/ \
          --cov=src/quantum_mlops \
          --cov-report=xml \
          --quantum-backend=${{ matrix.quantum-framework }}-simulator \
          -m "not hardware" \
          --timeout=300 \
          -x  # Stop on first failure for release testing
    
    - name: Validate Quantum Models
      run: |
        python scripts/release/validate_quantum_models.py \
          --framework ${{ matrix.quantum-framework }} \
          --test-circuits tests/circuits/ \
          --validate-serialization
    
    - name: Integration Test
      run: |
        python -c "
        import quantum_mlops
        from quantum_mlops import QuantumMLPipeline
        print(f'Successfully imported quantum-mlops v{quantum_mlops.__version__}')
        # Basic integration test
        pipeline = QuantumMLPipeline(lambda p, x: 0, n_qubits=2)
        print('Integration test passed')
        "

  # Build and package artifacts
  build-artifacts:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    needs: [determine-release, pre-release-testing]
    if: |
      always() && 
      needs.determine-release.outputs.should_release == 'true' &&
      (needs.pre-release-testing.result == 'success' || 
       github.event.inputs.skip_tests == 'true')
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Setup Python Environment
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Install Build Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine wheel
        pip install -e ".[dev]"
    
    - name: Update Version in Package
      run: |
        python scripts/release/update_version.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --files pyproject.toml src/quantum_mlops/__init__.py
    
    - name: Build Python Package
      run: |
        python -m build
        
        # Verify package contents
        twine check dist/*
    
    - name: Package Quantum Models and Circuits
      run: |
        python scripts/release/package_quantum_artifacts.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --output quantum-artifacts.tar.gz \
          --include-pretrained-models \
          --include-circuit-templates
    
    - name: Generate Package Checksums
      run: |
        cd dist
        sha256sum * > SHA256SUMS
        cd ..
        sha256sum quantum-artifacts.tar.gz >> dist/SHA256SUMS
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-artifacts
        path: |
          dist/
          quantum-artifacts.tar.gz
        retention-days: 90

  # Build multi-platform container images
  build-containers:
    name: Build Container Images
    runs-on: ubuntu-latest
    needs: [determine-release, pre-release-testing]
    if: |
      always() && 
      needs.determine-release.outputs.should_release == 'true' &&
      (needs.pre-release-testing.result == 'success' || 
       github.event.inputs.skip_tests == 'true')
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.CONTAINER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract Container Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}},value=${{ needs.determine-release.outputs.release_version }}
          type=semver,pattern={{major}}.{{minor}},value=${{ needs.determine-release.outputs.release_version }}
          type=semver,pattern={{major}},value=${{ needs.determine-release.outputs.release_version }}
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and Push Container Image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: ${{ env.BUILD_PLATFORMS }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          QUANTUM_MLOPS_VERSION=${{ needs.determine-release.outputs.release_version }}
          PYTHON_VERSION=${{ env.PYTHON_VERSION }}
    
    - name: Generate Container Attestation
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}
        subject-digest: ${{ steps.build.outputs.digest }}
        push-to-registry: true

  # Create GitHub release
  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [determine-release, build-artifacts, build-containers]
    if: always() && needs.determine-release.outputs.should_release == 'true'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Download Release Artifacts
      uses: actions/download-artifact@v4
      with:
        name: release-artifacts
        path: release-artifacts/
    
    - name: Create Git Tag
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git tag -a "v${{ needs.determine-release.outputs.release_version }}" \
          -m "Release v${{ needs.determine-release.outputs.release_version }}"
        git push origin "v${{ needs.determine-release.outputs.release_version }}"
    
    - name: Generate Release Notes
      run: |
        python scripts/release/generate_release_notes.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --changelog-content "${{ needs.determine-release.outputs.changelog }}" \
          --quantum-features \
          --performance-improvements \
          --output RELEASE_NOTES.md
    
    - name: Create GitHub Release
      uses: actions/create-release@v1
      id: create_release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ needs.determine-release.outputs.release_version }}
        release_name: Quantum MLOps Workbench v${{ needs.determine-release.outputs.release_version }}
        body_path: RELEASE_NOTES.md
        draft: false
        prerelease: ${{ contains(needs.determine-release.outputs.release_type, 'pre') }}
    
    - name: Upload Release Assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: release-artifacts/quantum-artifacts.tar.gz
        asset_name: quantum-mlops-workbench-v${{ needs.determine-release.outputs.release_version }}-quantum-artifacts.tar.gz
        asset_content_type: application/gzip
    
    - name: Upload Python Wheel
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: release-artifacts/dist/quantum_mlops_workbench-${{ needs.determine-release.outputs.release_version }}-py3-none-any.whl
        asset_name: quantum_mlops_workbench-${{ needs.determine-release.outputs.release_version }}-py3-none-any.whl
        asset_content_type: application/zip

  # Publish to PyPI
  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [determine-release, create-github-release]
    if: |
      always() && 
      needs.determine-release.outputs.should_release == 'true' &&
      needs.create-github-release.result == 'success'
    environment: pypi-release
    
    steps:
    - name: Download Release Artifacts
      uses: actions/download-artifact@v4
      with:
        name: release-artifacts
        path: release-artifacts/
    
    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        packages-dir: release-artifacts/dist/
        verbose: true
        print-hash: true

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [determine-release, build-containers]
    if: |
      always() && 
      needs.determine-release.outputs.should_release == 'true' &&
      (github.event.inputs.deploy_environment == 'staging' || 
       github.event.inputs.deploy_environment == 'all')
    environment: staging
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Deploy to Staging Environment
      run: |
        echo "Deploying quantum-mlops-workbench v${{ needs.determine-release.outputs.release_version }} to staging"
        
        # Update staging deployment configuration
        python scripts/deployment/update_staging_config.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --image "${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}:${{ needs.determine-release.outputs.release_version }}"
        
        # Deploy to staging (customize for your infrastructure)
        # kubectl apply -f deployment/staging/
        # or
        # docker-compose -f docker-compose.staging.yml up -d
        
        echo "Staging deployment completed"
    
    - name: Run Staging Smoke Tests
      run: |
        python scripts/deployment/staging_smoke_tests.py \
          --staging-url "${{ secrets.STAGING_URL }}" \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --quantum-tests

  # Deploy to production environment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [determine-release, build-containers, deploy-staging]
    if: |
      always() && 
      needs.determine-release.outputs.should_release == 'true' &&
      (github.event.inputs.deploy_environment == 'production' || 
       github.event.inputs.deploy_environment == 'all') &&
      (needs.deploy-staging.result == 'success' || 
       github.event.inputs.deploy_environment == 'production')
    environment: production
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Deploy to Production Environment
      run: |
        echo "Deploying quantum-mlops-workbench v${{ needs.determine-release.outputs.release_version }} to production"
        
        # Update production deployment configuration
        python scripts/deployment/update_production_config.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --image "${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}:${{ needs.determine-release.outputs.release_version }}"
        
        # Deploy to production (customize for your infrastructure)
        # kubectl apply -f deployment/production/
        # or
        # docker-compose -f docker-compose.production.yml up -d
        
        echo "Production deployment completed"
    
    - name: Run Production Health Checks
      run: |
        python scripts/deployment/production_health_checks.py \
          --production-url "${{ secrets.PRODUCTION_URL }}" \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --comprehensive-tests
    
    - name: Update Production Monitoring
      run: |
        python scripts/monitoring/update_production_dashboards.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --deployment-time "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  # Documentation deployment
  deploy-documentation:
    name: Deploy Documentation
    runs-on: ubuntu-latest
    needs: [determine-release, create-github-release]
    if: |
      always() && 
      needs.determine-release.outputs.should_release == 'true' &&
      needs.create-github-release.result == 'success'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Setup Python Environment
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Install Documentation Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"
        pip install sphinx sphinx-rtd-theme myst-parser
    
    - name: Build Documentation
      run: |
        cd docs
        make html
        
        # Update version in documentation
        sed -i "s/version = .*/version = '${{ needs.determine-release.outputs.release_version }}'/" conf.py
        make html
    
    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: docs/_build/html
        cname: quantum-mlops.readthedocs.io  # Update with your domain

  # Post-release notifications and cleanup
  post-release-tasks:
    name: Post-Release Tasks
    runs-on: ubuntu-latest
    needs: [determine-release, create-github-release, publish-pypi, deploy-production, deploy-documentation]
    if: always() && needs.determine-release.outputs.should_release == 'true'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Update Development Branch
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Create development branch if it doesn't exist
        git checkout -b develop || git checkout develop
        git merge main
        git push origin develop
    
    - name: Create Next Development Milestone
      uses: actions/github-script@v7
      with:
        script: |
          const { data: milestones } = await github.rest.issues.listMilestones({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });
          
          const currentVersion = '${{ needs.determine-release.outputs.release_version }}';
          const versionParts = currentVersion.split('.').map(Number);
          versionParts[1] += 1; // Increment minor version
          versionParts[2] = 0;   // Reset patch version
          const nextVersion = versionParts.join('.');
          
          const milestoneExists = milestones.find(m => m.title === `v${nextVersion}`);
          
          if (!milestoneExists) {
            await github.rest.issues.createMilestone({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `v${nextVersion}`,
              description: `Development milestone for version ${nextVersion}`,
              due_on: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString() // 90 days from now
            });
            
            console.log(`Created milestone for v${nextVersion}`);
          }
    
    - name: Send Release Notifications
      run: |
        python scripts/release/send_notifications.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --release-url "${{ needs.create-github-release.outputs.html_url }}" \
          --changelog "${{ needs.determine-release.outputs.changelog }}" \
          --slack-webhook "${{ secrets.SLACK_WEBHOOK_RELEASES }}" \
          --discord-webhook "${{ secrets.DISCORD_WEBHOOK_RELEASES }}"
    
    - name: Update Package Registries
      run: |
        # Update conda-forge recipe (if applicable)
        python scripts/release/update_conda_recipe.py \
          --version "${{ needs.determine-release.outputs.release_version }}" \
          --sha256 "$(cat release-artifacts/dist/SHA256SUMS | head -1 | cut -d' ' -f1)"
        
        # Update other package registries as needed
        echo "Release v${{ needs.determine-release.outputs.release_version }} completed successfully!"